<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>股票利益最大化</title><meta name="description" content="The harder you work, the luckier you will be~"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
问题定义
给定股票价格序列，规定(买入、卖出)的最多次数K，求最大的总利润。(一次买入和卖出为完整交易)
K=1 (Leetcode121)
记录遍历到第i天的时候之前的股票价格最小值，那么如果当天卖出，能取得最大利润肯定是当前股票价格减去之前最低的股票价格 最后取遍历的最大值。
class Solution &amp;#123;
public:
    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) &amp;#123;
        int max_profit = 0;
        int pre_min = INT_MAX;
        for(int i=0;i&amp;lt;prices.size();i++)
        &amp;#123;
            .."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Georgeqi_Blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Georgeqi's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">股票利益最大化</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89"><span class="toc-text">问题定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#k1-leetcode121"><span class="toc-text">K&#x3D;1 (Leetcode121)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#k2-leetcode123"><span class="toc-text">K&#x3D;2 (LeetCode123)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E9%99%90%E5%AE%9A%E4%B9%B0%E5%8D%96%E6%AC%A1%E6%95%B0-%E5%8D%B3kinf-leetcode122"><span class="toc-text">不限定买卖次数-即K&#x3D;inf (Leetcode122)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E6%9D%80%E5%99%A8-%E9%80%9A%E7%94%A8%E8%A7%A3%E6%B3%95"><span class="toc-text">大杀器-通用解法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B81-%E4%BA%A4%E6%89%8B%E7%BB%AD%E8%B4%B9leetcode714"><span class="toc-text">延伸1-交手续费(Leetcode714)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B82-%E5%90%8E%E4%B8%80%E5%A4%A9%E4%B8%8D%E5%85%81%E8%AE%B8%E4%B9%B0%E5%85%A5%E8%82%A1%E7%A5%A8leetcode309"><span class="toc-text">延伸2-后一天不允许买入股票(LeetCode309)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-%E4%BB%A5%E5%8D%96%E5%87%BA%E6%97%B6%E5%80%99%E6%9B%B4%E6%96%B0k%E5%80%BC"><span class="toc-text">拓展-以卖出时候更新k值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#reference"><span class="toc-text">Reference</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98"><i class="tag post-item-tag">算法刷题</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">股票利益最大化</h1><time class="has-text-grey" datetime="2020-02-27T02:45:26.000Z">2020-02-27</time><article class="mt-2 post-content"><p><img src="/2020/02/27/%E8%82%A1%E7%A5%A8%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96/cover_tree.png"></p>
<h1 id="问题定义">问题定义</h1>
<p>给定股票价格序列，规定(买入、卖出)的最多次数K，求最大的总利润。(一次买入和卖出为完整交易)</p>
<h1 id="k1-leetcode121">K=1 (<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">Leetcode121</a>)</h1>
<p>记录遍历到第i天的时候之前的股票价格最小值，那么如果当天卖出，能取得最大利润肯定是当前股票价格减去之前最低的股票价格 最后取遍历的最大值。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>class Solution &#123;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>public:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max_profit = <span class="dv">0</span>;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pre_min = INT_MAX;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;prices.size();i++)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            max_profit=max(max_profit,prices[i]-pre_min);</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            pre_min = min(pre_min,prices[i]);</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max_profit;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h1 id="k2-leetcode123">K=2 (<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">LeetCode123</a>)</h1>
<p>相当于找两个利润最大的价格区间，并且这两个区间是不重叠的，也就是说这两个区间左右一个，那么如果在第i天把区间分成两部分，所以借用k=1的思路，每部分分别求各自的最大利益，然后遍历每天，求左右两部分最大的两个利益，最后去最大值即可。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">0</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len=prices.size();</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> *dp_left=<span class="kw">new</span> <span class="dt">int</span>[len];</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> *dp_right=<span class="kw">new</span> <span class="dt">int</span>[len];</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        dp_left[<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> min_val=INT_MAX,max_profit=<span class="dv">0</span>;</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>             max_profit=dp_left[i]=max(max_profit,prices[i]-min_val);</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>             min_val=min(min_val,prices[i]);</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        max_profit=<span class="dv">0</span>;</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> high_val=-<span class="dv">1</span>;</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=len-<span class="dv">1</span>;i&gt;=<span class="dv">0</span>;i--)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>             max_profit=dp_right[i]=max(max_profit,high_val-prices[i]);</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>             high_val=max(high_val,prices[i]);</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        max_profit=<span class="dv">0</span>;</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            max_profit=max(max_profit,dp_left[i]+dp_right[i]);</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max_profit;</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h1 id="不限定买卖次数-即kinf-leetcode122">不限定买卖次数-即K=inf (<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">Leetcode122</a>)</h1>
<p>因为不限制买卖次数，则此时每一个上升区间的两端，都分别可以进行买入和卖出，只需要统计每个上升区间的落差就行。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//寻找连续的波峰和波谷即可,不跨越任何一个波峰</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">0</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxProfit=<span class="dv">0</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> valley=prices[<span class="dv">0</span>];</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> peak=prices[<span class="dv">0</span>];</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>,len=prices.size()-<span class="dv">1</span>;</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(i&lt;len)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">//下坡</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span>(i&lt;len &amp;&amp; prices[i+<span class="dv">1</span>]&lt;=prices[i])</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                i++;</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            valley = prices[i]; </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">//上破</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span>(i&lt;len &amp;&amp; prices[i+<span class="dv">1</span>]&gt;=prices[i])</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                i++;</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            peak = prices[i]; </span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            maxProfit += peak-valley;</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxProfit;</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<p>简单形式：不需要显示的求出每个上升区间的落差，只要是上升的，那么在该区间内用后一天价格减去当天价格，对所有差求和就是区间的落差。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//和寻找连续的波峰波谷是同样的思路，但是不用具体找到确切的波峰和波谷的位置</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">0</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxProfit=<span class="dv">0</span>;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i=<span class="dv">0</span>,len=prices.size()-<span class="dv">1</span>;</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span>(i&lt;len)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">//只要找到上升的路径，就不断累加</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(prices[i+<span class="dv">1</span>]&gt;=prices[i])</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                maxProfit += prices[i+<span class="dv">1</span>]-prices[i];</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            i++;</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxProfit;</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h1 id="大杀器-通用解法">大杀器-通用解法</h1>
<p>使用动态规划的思想： dp[n][k][flag]：表示在第n天时，最多买入k次股票，且目前手里持有股票的状态是flag。其中天数从0开始， flag=0表示目前手里没有股票，flag=1表示手里还有股票，其中在股票买入的时候，对k进行更新。 状态转移方程： <span class="math display">\[
dp[n][k][0]=max(dp[n-1][k][0], dp[n-1][k][1]+prices[n])
\]</span></p>
<p>上式解释:今天(n天)手里没有股票，且最多买入了k次股票,有两种可能: 1.昨天手里就没有股票，也今天没有进行买卖操作(k不会变)，所以今天手里还是没有股票，收益不变，仍为dp[n-1][k][0] 2.昨天手里有股票，今天把手里价值为price[n]的股票卖了(k也不会变)，收益变成dp[n-1][k][1]+price[n] (买入股票时才修改k) <span class="math display">\[
dp[n][k][1]=max(dp[n-1][k][1], dp[n-1][k-1][0]-prices[n])
\]</span> 上式解释:今天(n天)手里有股票，有两种可能:</p>
<ul>
<li>昨天手里就有股票今天没有进行买入操作(k不变)，所以今天手里仍然保留股票，收益不变:dp[n-1][k][1]。</li>
<li>昨天手里没有股票，今天买入价值为price[n]的股票(k发生改变)，收益变成dp[n-1][k-1][0]-price[n]。(以买入股票作为一个交易结束，所以k-1)</li>
</ul>
<p><strong>初始化：</strong></p>
<ul>
<li><strong>dp[i][0][0]=0</strong>表示到第i天，最多使用了0次交易(就是说并未买入任何股票)，那肯定就是0</li>
<li><strong>dp[i][0][1]=</strong><span class="math inline">\(-\infty\)</span>表示到第i天，并未买入任何股票的情况下，手里持有股票，这是肯定不正确的，置为负无穷</li>
<li><strong>dp[0][k][0]=0</strong>表示第0天时，最多使用了k次交易(即买入了k次股票,其实最多也就买入了一次)且手里没有股票，肯定是0</li>
<li><strong>dp[0][k][1]=-prices[0]</strong> 表示第0天时，最多使用了k次交易(即买入了k次股票,其实最多也就买入了一次)且手里已经有股票了，表明在在第一天已经买入股票了。(此时k必须大于1)</li>
</ul>
<p>PS：对于以卖出时候更新k的解法，读者可自行分析，参考件本文最下方；</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">0</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len=prices.size();</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> K_max=<span class="dv">2</span>;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        vector&lt;vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt;&gt; dp(len,vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt;(K_max+<span class="dv">1</span>,vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>)));</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">//K为任意正整数的通用解法-状态机+三维DP(买入股票时,k发生改变)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>][<span class="dv">1</span>]=-INT_MAX;</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> k=K_max;k&gt;=<span class="dv">1</span>;k--)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            dp[<span class="dv">0</span>][k][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            dp[<span class="dv">0</span>][k][<span class="dv">1</span>]=-prices[<span class="dv">0</span>];</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">//接下来对第0天之后的情况使用状态转移方程计算即可</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> n=<span class="dv">1</span>;n&lt;len;n++)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span>(<span class="dt">int</span> k=K_max;k&gt;=<span class="dv">1</span>;k--)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            &#123;</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                dp[n][k][<span class="dv">0</span>]=max(dp[n-<span class="dv">1</span>][k][<span class="dv">0</span>],dp[n-<span class="dv">1</span>][k][<span class="dv">1</span>]+prices[n]);</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                dp[n][k][<span class="dv">1</span>]=max(dp[n-<span class="dv">1</span>][k][<span class="dv">1</span>],dp[n-<span class="dv">1</span>][k-<span class="dv">1</span>][<span class="dv">0</span>]-prices[n]);</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            &#125; </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">//在最后一天(len-1)最多使用K_max次交易,肯定是把手里股票卖光收益更高(不然留着手里发霉啊？)</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">//所以是dp[len-1][K_max][0]，而非dp[len-1][K_max][1]</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">//其次，最多使用K_max次交易交易肯定是包括最多使用K_max-1次，K_max-2次交易的情况。</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[len-<span class="dv">1</span>][K_max][<span class="dv">0</span>];</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<p>ps:对于 K=+<span class="math inline">\(\infty\)</span>的情况，此时K已经毫无意义，可以直删除该维度，代码精简如下:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">0</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len=prices.size();</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; dp(len,vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>));</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>]=<span class="dv">0</span>;    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">1</span>]=-INT_MAX;</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][<span class="dv">1</span>]=-prices[<span class="dv">0</span>];</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> n=<span class="dv">1</span>;n&lt;len;n++)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            dp[n][<span class="dv">0</span>]=max(dp[n-<span class="dv">1</span>][<span class="dv">0</span>],dp[n-<span class="dv">1</span>][<span class="dv">1</span>]+prices[n]);</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            dp[n][<span class="dv">1</span>]=max(dp[n-<span class="dv">1</span>][<span class="dv">1</span>],dp[n-<span class="dv">1</span>][<span class="dv">0</span>]-prices[n]);</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[len-<span class="dv">1</span>][<span class="dv">0</span>];</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<p>此外，对于通用的形式，可以看见循环中，第一维度的变化是步长为1递减的，所以可以进一步对通用形式进行空间优化。不然在总天数和k很大的时候无法通过<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LeetCode188</a>：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(<span class="dt">int</span> k, vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> N=prices.size();</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(N&lt;=<span class="dv">1</span>) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(k&gt;N/<span class="dv">2</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            k=N/<span class="dv">2</span>+<span class="dv">1</span>;</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//套用通用解法模板(买入时更新k)</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; dp(k+<span class="dv">1</span>,vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>));</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> m=<span class="dv">0</span>;m&lt;=k;m++)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            dp[m][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            dp[m][<span class="dv">1</span>]=-prices[<span class="dv">0</span>];</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][<span class="dv">1</span>]=-INT_MAX;</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">//因为n都是每次步长为1递减的,所以为了优化内存,可以把三维dp变为二维dp</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> n=<span class="dv">1</span>;n&lt;N;n++)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span>(<span class="dt">int</span> m=k;m&gt;=<span class="dv">1</span>;m--)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            &#123;</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>               dp[m][<span class="dv">0</span>]=max(dp[m][<span class="dv">0</span>],dp[m][<span class="dv">1</span>]+prices[n]);   </span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>               dp[m][<span class="dv">1</span>]=max(dp[m][<span class="dv">1</span>],dp[m-<span class="dv">1</span>][<span class="dv">0</span>]-prices[n]); </span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            &#125;</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[k][<span class="dv">0</span>];</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h2 id="延伸1-交手续费leetcode714">延伸1-交手续费(<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Leetcode714</a>)</h2>
<p>如每次完整的交易需要交手续费(<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Leetcode714</a>)，同样可以使用通用解法：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices, <span class="dt">int</span> fee) &#123;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len=prices.size();</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(len&lt;=<span class="dv">1</span>) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; dp(len,vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>));</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">1</span>]=-INT_MAX;</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//规定在卖出股票的时候扣手续费，所以第一天手里如果有股票，不需要扣手续费</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//ps:也可以规定在买入股票的时候扣手续费，所以第一天手里如果有股票，需要扣手续费：</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">//即变成dp[0][1]=-prices[0];</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][<span class="dv">1</span>]=-prices[<span class="dv">0</span>];</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;len;i++)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">//每次完整的交易才需要交一个手续费，所以是在卖出股票的时候交手续费</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>]=max(dp[i-<span class="dv">1</span>][<span class="dv">0</span>],dp[i-<span class="dv">1</span>][<span class="dv">1</span>]+prices[i]-fee);</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">1</span>]=max(dp[i-<span class="dv">1</span>][<span class="dv">1</span>],dp[i-<span class="dv">1</span>][<span class="dv">0</span>]-prices[i]); <span class="co">//如果规定买入时扣手续费,那么在这里减去fee</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[len-<span class="dv">1</span>][<span class="dv">0</span>];</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h2 id="延伸2-后一天不允许买入股票leetcode309">延伸2-后一天不允许买入股票(<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode309</a>)</h2>
<p>延伸2.每次卖出股票后，后一天不允许买入股票<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LeetCode309</a>：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">1</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len=prices.size();</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt; dp(len,vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>));</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">//第0天手里没有股票和有股票，收益分别是0和-prices[0]</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][<span class="dv">0</span>] = <span class="dv">0</span>;</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][<span class="dv">1</span>] = -prices[<span class="dv">0</span>];</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">//第1天手里没有股票的两种情况:1.根本没买过 2.在第0天买了，第二天卖了</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">//第1天手里有股票的两种情况:1.第0天买的 2.在第1天买的</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">1</span>][<span class="dv">0</span>] = max(<span class="dv">0</span>,prices[<span class="dv">1</span>]-prices[<span class="dv">0</span>]);</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">1</span>][<span class="dv">1</span>] = max(-prices[<span class="dv">0</span>],-prices[<span class="dv">1</span>]);</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> n=<span class="dv">2</span>;n&lt;len;n++)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            dp[n][<span class="dv">0</span>]=max(dp[n-<span class="dv">1</span>][<span class="dv">0</span>],dp[n-<span class="dv">1</span>][<span class="dv">1</span>]+prices[n]);</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">//当天手里有股票，可能昨天就有但是没进行任何操作，或者前天卖掉股票后手里没股票，然后昨天被冻结了</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            dp[n][<span class="dv">1</span>]=max(dp[n-<span class="dv">1</span>][<span class="dv">1</span>],dp[n-<span class="dv">2</span>][<span class="dv">0</span>]-prices[n]);</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[len-<span class="dv">1</span>][<span class="dv">0</span>];</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h1 id="拓展-以卖出时候更新k值">拓展-以卖出时候更新k值</h1>
<p>dp[n][k][flag]：表示在第n天时，最多卖出了k次股票，目前手里持有股票的状态是flag， flag=0表示目前手里没有股票，flag=1表示手里还有股票<br>
<span class="math display">\[
dp[n][k][0]=max(dp[n-1][k][0],dp[n-1][k-1][1]+price[n])
\]</span> 上式解释:今天(n天)手里没有股票，且最多卖出了k次股票,有两种可能:</p>
<ul>
<li>昨天手里就没有股票，且今天没有进行买卖操作(k不会变)，所以今天手里还是没有股票，收益不变，仍为dp[n-1][k][0]</li>
<li>昨天手里有股票，今天把手里价值为price[n]的股票卖了(k会发生变化)，收益变成dp[n-1][k][1]+price[n]</li>
</ul>
<p><span class="math display">\[
dp[n][k][1]=max(dp[n-1][k][1],dp[n-1][k][0]-price[n])
\]</span> 上式解释:今天(n天)手里有股票，有两种可能:</p>
<ul>
<li>昨天手里有股票今天没有进行买入操作(k不变)，所以今天手里仍然保留股票，收益不变:dp[n-1][k][1]。</li>
<li>昨天手里没有股票今天买入价值为price[n]的股票(k不变)，收益变成dp[n-1][k-1][0]-price[n]。</li>
</ul>
<p><strong>初始状态:</strong></p>
<ul>
<li><strong>dp[i][0][0]=0</strong>表示到第i天，最多使用了0次交易(就是说并未卖出任何股票)，那肯定就是0</li>
<li><strong>dp[i] [0] [1]=max{-price[z]}</strong> (其中z=0,1,2...i) 表示到第i天，并未卖出任何股票的情况下，手里持有股票，这说明买入了一次股票,<strong>那么有可能其实在第0天第i天之间任何一天买入的股票,为了保证dp[i][0][1]尽量最大</strong>(因为本身问题就是一个最大化的问题,所以令其该天及之前之前最小价格的负数)。</li>
<li><strong>dp[0][k][0]=0</strong>表示第0天时，最多使用了k次交易(即卖出了k次股票,其实最多就买入一次)且手里没有股票，肯定是0(有可能第一天根本就没买，也有可能当天买当天卖，反正都是0)</li>
<li><strong>dp[0][k][1]=-prices[0]</strong> 表示第0天时，最多使用了k次交易(即卖出了k次股票,其实最多也就卖出了一次)且手里已经有股票了，说明在卖出股票后又买了一次股票,收益肯定就是-prices[0] (由上面的分析可知，这里k等于0也是一样的) 代码如下:</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution &#123;</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit(vector&lt;<span class="dt">int</span>&gt;&amp; prices) &#123;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span>(prices.size()&lt;=<span class="dv">0</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> len=prices.size();</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> K_max=<span class="dv">2</span>;</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        vector&lt;vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt;&gt; dp(len,vector&lt;vector&lt;<span class="dt">int</span>&gt;&gt;(K_max+<span class="dv">1</span>,vector&lt;<span class="dt">int</span>&gt;(<span class="dv">2</span>)));</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> min_val=INT_MAX;</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;i&lt;len;i++)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            min_val=min(min_val,prices[i]);</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            dp[i][<span class="dv">0</span>][<span class="dv">1</span>]=-min_val;</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> k=K_max;k&gt;=<span class="dv">1</span>;k--)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            dp[<span class="dv">0</span>][k][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            dp[<span class="dv">0</span>][k][<span class="dv">1</span>]=-prices[<span class="dv">0</span>];</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">//接下来对第0天之后的情况使用状态转移方程计算即可</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span>(<span class="dt">int</span> n=<span class="dv">1</span>;n&lt;len;n++)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        &#123;</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span>(<span class="dt">int</span> k=K_max;k&gt;=<span class="dv">1</span>;k--)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            &#123;</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>                dp[n][k][<span class="dv">0</span>]=max(dp[n-<span class="dv">1</span>][k][<span class="dv">0</span>],dp[n-<span class="dv">1</span>][k-<span class="dv">1</span>][<span class="dv">1</span>]+prices[n]);</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>                dp[n][k][<span class="dv">1</span>]=max(dp[n-<span class="dv">1</span>][k][<span class="dv">1</span>],dp[n-<span class="dv">1</span>][k][<span class="dv">0</span>]-prices[n]);</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>            &#125; </span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        &#125;</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[len-<span class="dv">1</span>][K_max][<span class="dv">0</span>];</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    &#125;</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>&#125;;</span></code></pre></div>
<h1 id="reference">Reference</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/12/10/Diffusion%E5%AD%A6%E4%B9%A01-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/" title="Diffusion学习1-预备知识"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Diffusion学习1-预备知识</span></a><a class="button is-default" href="/2020/02/26/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9D%83%E9%87%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/" title="神经网络权重初始化问题的思考"><span class="has-text-weight-semibold">Next: 神经网络权重初始化问题的思考</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="qzq2514/qzq2514.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com/qzq2514"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/qzq2514"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com/qzq2514"><i class="iconfont icon-ins"></i></a><!-- publish--><a title="publish" target="_blank" rel="noopener nofollow" href="https://blog.csdn.net/qzq2514"><i class="iconfont icon-rss"></i></a><!-- RSS--><!-- 知乎--><a title="zhihu" target="_blank" rel="noopener nofollow" href="//zhihu.com/people/qi-zhong-qi-62"><i class="iconfont icon-zhihu"></i></a><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Georgeqi 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>